package main

import (
	"fmt"
	"math"
	"unicode"
)

var input = []string{
	"#################################################################################",
	"#.....#...............#.....#.A.#.......#.....#e..............#.....#...........#",
	"#.###.#########.#####.###.#.###.#.###.#.###.#.###.###########.#.#.###.#####.#####",
	"#.#.#.....#...#.#...#.#...#.....#.#.#.#.#...#..m#...#.......#.#.#.#...#.#...#...#",
	"#.#.#####.#.#.#.#.###.#.#########.#.#.###.#####.###.#.#######.###.#.###.#N###.#.#",
	"#.#.#...#...#...#...#.#.....T.......#...#.#...#.....#.#.....#.#...#.....#.#...#.#",
	"#.#.#.#.###########.#.#.###############.#.#.#.#######.#.###.#.#.#.#####.#.#.###.#",
	"#.#...#.......#.....#.#.......#.....#...#.#.#...#.........#j....#.#...#.#.#.#...#",
	"#.###########.#.#.#.#.#########.###.#.#.#.#.###.#.#########.#####.###.#.#.#.#.#.#",
	"#.#.....#...#.#.#.#.#...........#...#.#.#.#...#.#.#...#...#.#...#...#.#.#...#.#.#",
	"#.#P###.#D#.#.#.#.###############.###.#.#.###.#.#.###.#.#.###.#.###.#.#.#####.###",
	"#...#...#.#.#u..#.......#...#.....#...#.#.#...#.......#.#.....#...#...#.....#...#",
	"#####.###.#.#######.###.#.###.#######.#.#.#########.###.#########.#########.###.#",
	"#...#.#...#g......#...#.#...#.#.....#.#.#.#...#...#.#...#.......#.#.........#...#",
	"#.#.#.#.#########.###.#.###.#.###.#.#.#.#.#.#.#.#.###.#######.#.#.#.#########O#.#",
	"#.#...#..d#.....#...#.#.....#.....#...#.#...#...#.....#.....#.#.#...#.....#...#.#",
	"#.#######.#.###F###.#.#################.#.###############.#.#.#.#######.#.#.###.#",
	"#.....#...#..h#...#.#.............#.....#.#.......#.......#...#.....#...#.#.#...#",
	"#.###.#H#####.#.###G#.#######.#####.#####.###.#.#.#.###.###########.#.###.#.#####",
	"#.#.#.#.......#.#...#.....#...#...#.#...#...#.#.#.#...#.#...#.....#...#.#.#.....#",
	"#.#.#.#########.#.#########.###.#.#.###.###.#.#.#.#####.#.#.#####.#####.#.#####.#",
	"#...#.....#.....#b..#...#...#...#...#...#...#.#.#.....#...#.#y..#.......#.....#.#",
	"###.#####.#.#######.###B#.#.#.#######.#.#.#####.#####.#.###.###.#####.#.#.#####.#",
	"#...#...I.#f......#.....#.#.#.#...#...#.#...#...#...#.#.#.....#.....#.#...#.....#",
	"#####.###########.#######.###.#.###.#.#####.#.###.###.###.#########.#######.#####",
	"#o....#k........#.#.#.......#.#.#...#...#.#.#.#.....#.#...#.......#.......K.#...#",
	"#.#####.###.#####.#.#.#####.#.#.#.#####.#.#.#.###.#.#.#.###.###.###############.#",
	"#.#.......#...#.C.#.....#...#.#...#...#.#...#...#.#.#.#...#...#.....#...........#",
	"#.#.#########.#.#########.###.###.#.###.#.#####.#.#.#.###.###.#####.#.#.#######.#",
	"#...#l........#...#.....#...#...#...#...#.......#.#...#...#...#...#...#.X.#...#.#",
	"#.###.#.#########.#V###.###.###.#####.###########.#####.###.###.#########.#.#.#.#",
	"#...#.#.#.....#...#.#.#.#...#.#.....#...#.......#...#...#...#...........#.#.#.#.#",
	"#####.#.#.###.#.###.#.#.#.#.#.#####.###.#.#####.###.#.#.#.###.#######.###.#.#.#W#",
	"#.....#.#.#r#.#.#...#.#.#.#.#.#...#...#.#.#...#...#.#.#.#...#.......#...#.#.#.#.#",
	"#.#######.#.#.#.###.#.#.#.#.#.#.#.###.#.#.###.###.#.#.#.###.###########.#.#.#.#.#",
	"#.........#.#.#.#s..#...#.#.Q.#.#.#...#.#...#...#...#.#.............#...#.#.#...#",
	"#.#########.#.#.#.###.###.#.###.#.#.###.###.#.#.#####.#######.#####.#.###.#.#####",
	"#...#...#...#.#...#...#...#.#...#...#...#.#.#.#.....#...#...#.#...#...#...#...#.#",
	"###.#Y#.###.#.#####.###.#####.#########.#.#.###.###.#####.#.###.#.#####.#####.#.#",
	"#.....#.....#.......#...........................#.........#....q#.......#.......#",
	"#######################################.@.#######################################",
	"#...#.#.................#..z..............#.......#.............#...............#",
	"#.#.#.#.#.#############.#.#.###########.#.#.#.#####.#####.#####.#.###.#########.#",
	"#.#...#.#.#...#.#.....#.#.#.#.....#...#.#...#.#...Z.....#.#.....#.#.#.#.......#.#",
	"#.#####.#.#.#.#.#.#.#.#.###.#.#####.#.#.#.###.#.#########.#######.#.#.#####.###.#",
	"#.#...#.#...#.#...#.#x#.#...#.#.....#.#.#...#.....#.....#.#...#.....#.#...#.....#",
	"#.#.#.#.#####.#####.###.#.###.#.#####.#.###.#######.###.#.#.#.#.#####.#.#.#####.#",
	"#w..#...#...#.....#.#.....#...#.#.....#.#.#...#.....#.#...#.#...#..v#.#.#.....#.#",
	"#.#######.#.#####.#.#.#####.###.#.#####.#.###.#.#####.#.###.#####.#.#.#.#####.###",
	"#.#.......#.#.#...#.#.#...#.#...#.#...#.#...#.#.#.......#...#...#.#.#.#.#...#...#",
	"#.###.#.###.#.#.###.#.#.#.#.#.###.#.#.#.#.###.#.###.#####.###.#.#.#.#.#.###.###.#",
	"#...#.#...#...#.#.#...#.#.#...#.#.#.#...#...#.#...#.#...#.#...#.R.#.#.........#.#",
	"###.#####.###.#.#.#.###.#.###.#.#.#.#####.#.#.###.#.#.#.#.#.#######.#.#########.#",
	"#.#...#...#.#.#.#.....#.#...#...#.......#.#.#...#.#...#.#.#.#...#...#.#.........#",
	"#.###.#.###.#.#.#######.###.#.#########.#.#.###.#.#######.#.#.###.###.#.#######.#",
	"#...#...#...#.#.........#...#.#...#.....#.#...#.#.........#.#.#...#...#.#.......#",
	"#.#######.#.#.###########.#####.#.#####.###.###.###########.#.#.#######.#########",
	"#.........#.#.#.........#.......#.#...#.#...#...#...........#.#.#.....#.........#",
	"#.###.#######.#.###.#####.#####.#.#.#.###.#.#.###.###########.#.#.###S#########.#",
	"#...#.......#...#...#...#.#...#.#...#...#.#.#...#.....L.#.....#...#...#...#...#.#",
	"#.#########.#####.###.#.###.#.###.#####.#.#####.#######.#.#########.###.#.#.#.#.#",
	"#.#.......#.#...#.#.#.#.#...#...#...#...#...........#...#...#.#....c#...#...#.#.#",
	"###.#####.#.#.#.#.#.###.#.#####.#####.###.###########.#####.#.#.#####.#######.#.#",
	"#...#.......#.#...#...#...#...#...#...#.#...#.........#.....#...#.......#.......#",
	"#.###.#######.#####.#######.#.###.#.###.###.#.###########.#.#########.#.#######.#",
	"#.#.#.#...#...#.............#...#...#...#...#.............#.........#.#.#.....#.#",
	"#.#.#.#.#.#.###########.#####.#.#####.###.#########################.###.#.###.#.#",
	"#.#...#.#.#.....#.....#...#...#.#.#.....#.....#...#.......#.......#...#...#...#.#",
	"#.#####.#.#####.#.###.#####.###.#.#.###.#####.#.###.###.###.#####.###.#####.#####",
	"#.......#...#.#...#.#.#.....#.#.#...#...#...#.#.#.....#.........#...#.....#.....#",
	"#.#######.#.#.#####E#.#.#####.#.#.###.#.#.#.#.#.#.#############.#.#.#####.###.#.#",
	"#...#.....#...#...#...#.#.....#.#...#.#.#.#...#.....#..a#.....#.#.#...#.#...#.#.#",
	"#####.#######.#.###.###.#.###.#.#.###.#.#.###########.#.#.###.###.###.#.###.###.#",
	"#...#.#.#...#.#.#...#...#.#...#.#.#...#.#.....#.....#.#.#.#.#...#...#...#.#...#.#",
	"#.#.#.#.#.#.#.#.#.###.#.#.#.#.#.###.###.#####.#.###.#.#.#.#.###.###.###.#.###.#.#",
	"#.#.#.#.#.#.....#.#...#.#.#.#.#.....#.#.#.....#.#...#.#...#...#...#.#.#.#...#..i#",
	"#.#.#.#.#.#######.#####.###.#########.#.#.#####U#.###.#######.###.#.#.#.#.#.#####",
	"#.#n..#.......#...#...#...#.#...#.......#.......#t#...#.........#.#.#.#...#.#...#",
	"#.#############.###.#.###.#.#.#.#.###############.#.###.#.#######.#.#.#####.#.#.#",
	"#...............J...#.....#...#.........#...........#...#.........M.#..p......#.#",
	"#################################################################################",
}

func main() {
	startingCoords := &Coordinates{0, 0}
	keys := ""
	for row := 0; row < len(input); row++ {
		for col := 0; col < len(input[0]); col++ {
			if string(input[row][col]) == "@" {
				startingCoords.row = row
				startingCoords.col = col
			} else if unicode.IsLower(rune(input[row][col])) {
				keys += string(input[row][col])
			}
		}
	}

	cache := make(map[KeyEntry]int)
	dist := distanceToCollectKeys(keys, cache, "@", startingCoords)
	fmt.Println("Part 1 : ", dist)
}

func distanceToCollectKeys(keysToCollect string, cache map[KeyEntry]int, currentKey string, currentCoords *Coordinates) int {
	if len(keysToCollect) == 0 {
		return 0
	} else if val, ok := cache[KeyEntry{currentKey, keysToCollect}]; ok {
		return val
	}

	result := -1
	for index, key := range keysToCollect {
		keyCoords, keyDist := findKey(currentCoords, key, keysToCollect)
		if keyDist < 0 {
			continue
		}

		distance := keyDist + distanceToCollectKeys((string(keysToCollect[:index])+string(keysToCollect[index+1:])), cache, string(key), &keyCoords)
		if result == -1 {
			result = distance
		} else {
			result = int(math.Min(float64(distance), float64(result)))
		}

		cache[KeyEntry{currentKey, keysToCollect}] = result
	}
	return result
}

func findKey(start *Coordinates, key rune, keysToCollect string) (Coordinates, int) {
	dist := 0

	queue := []Coordinates{*start}
	visited := map[Coordinates]bool{*start: true}
	for len(queue) > 0 {
		dist++
		newQueue := []Coordinates{}
		for _, loc := range queue {
			for _, neighbor := range []Coordinates{
				Coordinates{loc.row - 1, loc.col},
				Coordinates{loc.row + 1, loc.col},
				Coordinates{loc.row, loc.col - 1},
				Coordinates{loc.row, loc.col + 1},
			} {
				if !visited[neighbor] && isReachable(neighbor, keysToCollect) {
					if string(input[neighbor.row][neighbor.col]) == string(key) {
						return neighbor, dist
					}
					newQueue = append(newQueue, neighbor)
					visited[neighbor] = true
				}
			}
		}
		queue = newQueue
	}

	return Coordinates{-1, -1}, -1
}

func isReachable(coords Coordinates, keysToCollect string) bool {
	if coords.row < 0 || coords.row >= len(input) {
		return false
	} else if coords.col < 0 || coords.col >= len(input[0]) {
		return false
	} else if string(input[coords.row][coords.col]) == "#" {
		return false
	} else if unicode.IsUpper(rune(input[coords.row][coords.col])) {
		for _, key := range keysToCollect {
			if string(unicode.ToLower(rune(input[coords.row][coords.col]))) == string(key) {
				return false
			}
		}
	}
	return true
}

type Coordinates struct {
	row int
	col int
}

type KeyEntry struct {
	currentKey    string
	availableKeys string
}
